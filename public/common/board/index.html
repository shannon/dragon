<!DOCTYPE html>
<script type="text/javascript">
  
  angular.module('dragon.board', ['ngAnimate', 'ngMaterial', 'hmTouchEvents', 'RecursionHelper'])
  
  .constant('mathUtils', {
    tween: function(time, beginning, change, duration){
      return change * time / duration + beginning;
    },
    
    dot: function(a, b){
      //normalize a
      var length = Math.sqrt(a.x * a.x + a.y * a.y);
      a = angular.copy(a);
      a.x /= length;
      a.y /= length;
      return a.x * b.x + a.y * b.y;
    }
  })
  
  .constant('CARDINAL_VECTORS', {
    e:  { x: 1 ,  y: 0 ,  a: 0  ,  s: 1},
    ne: { x: 1 ,  y: -1,  a: 45 ,  s: Math.sqrt(2)},
    n:  { x: 0 ,  y: -1,  a: 90 ,  s: 1},
    nw: { x: -1,  y: -1,  a: 135,  s: Math.sqrt(2)},
    w:  { x: -1,  y: 0 ,  a: 180,  s: 1},
    sw: { x: -1,  y: 1 ,  a: 225,  s: Math.sqrt(2)},
    s:  { x: 0 ,  y: 1 ,  a: 270,  s: 1},
    se: { x: 1 ,  y: 1 ,  a: 315,  s: Math.sqrt(2)}
  })

  .directive('dragonBoard', ['$timeout', 'mathUtils', 'CARDINAL_VECTORS', function($timeout, mathUtils, CARDINAL_VECTORS){
    
    return {
      restrict: 'E',
      scope: {
        game: '=',
        static: '='
      },
      link: function(scope, elem, attrs){
        var $window = angular.element(window);
        var $grid   = elem[0].querySelector('.grid');
        
        scope.selection = {
          piece:  null,
          moves:  null,
          origin: null,
          frames: null,
          move:   null,
          dest:   null,
          drag:   false,
          clear: function(){
            this.piece    = null;
            this.moves    = null;
            this.origin   = null;
            this.frames   = null;
            this.move     = null;
            this.dest     = null;
            this.drag     = false;
          }
        }
        
        scope.screenfull = screenfull;
        
        scope.fullscreen = function(){
          if(screenfull.enabled) {
            screenfull.toggle(elem[0]);
          }
        };
        
        scope.restart = function(){
          if(scope.win || confirm('Are you sure you want to restart the game?')){
            scope.cancel();
            scope.game.restart([1, 2]);
            scope.win = null;
          }
        }
        
        scope.accept = function(){
          scope.selection.piece.move(scope.selection.move.dir, scope.selection.move.steps);
          scope.win = scope.game.play();
          scope.cancel();
        };
        
        scope.cancel = function(){
          
          [].slice.call($grid.querySelectorAll('.highlight')).forEach(function(elem){
            elem.classList.remove('highlight');
            elem.offsetHeight;
            elem.classList.add('highlight');
          });
          
          scope.game.board.spaces.forEach(function(space){
            delete space.highlight;
          });
          
          scope.selection.clear();
        };
        
        scope.select = function(piece){
          if(scope.selection.piece !== piece && piece.player === scope.game.turn){
            scope.cancel();
            
            var moves = piece.moves();
            var links = piece.links.slice();
            var frames = {};
            
            piece.space.highlight = { steps: 0, size: piece.type.size };
            
            for(var dir in moves){
              links = piece.links.slice();
              
              if(links.length && moves[dir]){
                frames[dir] = [];
                frames[dir][0] = links.slice(0, piece.links.length);
              }
              
              for(var s = 0; s < moves[dir]; s ++){
                
                var space = piece.space.adjacent(dir, (s + 1) * piece.type.size);
                space.highlight = { dir: dir, steps: s + 1, size: piece.type.size };
                
                if(links.length){
                  links.unshift(dragon.REVERSE[dir]);
                  frames[dir][s + 1] = links.slice(0, piece.links.length);
                }
              }
            }
            
            scope.selection.piece = piece;
            scope.selection.moves = moves;
            scope.selection.frames = frames;
            scope.selection.origin = {
              x: piece.space.x + 0.5,
              y: piece.space.y + 0.5
            }
            
            scope.selection.move = { steps: 0 };
          }
        }
        
        scope.$on('cancel', function(event){
          if(event.targetScope !== event.currentScope){
            scope.cancel();
          }
        });
        
        window.requestAnimationFrame(function raf(){
          var dest = scope.selection.dest;
          var move = scope.selection.move;
          
          if(dest && move && !angular.equals(dest, move)){
            
            if(!dest.dir || dest.dir !== move.dir){ //count down to 0 first
              move.steps = Math.max(0, move.steps - 0.25);
              
              if(move.steps === 0){ move.dir = dest.dir; }
            } else {
              move.dir = dest.dir;
              move.steps += Math.min(Math.max(dest.steps - move.steps, -0.25), 0.25);
            }
            
            scope.$digest();
            
          }
          window.requestAnimationFrame(raf);
        });
        
        (function(){ //input events
          var cache   = {};
          
          
          $window.bind('touchstart mousedown', function(e){
            e = e.touches && e.touches[0] || e;
            
            var space = (angular.element(document.elementFromPoint(e.clientX, e.clientY)).scope() || {}).space;
            
            if(space){
              if(space.highlight){
                scope.selection.dest = space.highlight;
                scope.selection.drag = true;
              } else if(space.occupied || (scope.selection.piece && scope.selection.piece.space === space)){
                scope.select(space.occupied || scope.selection.piece);
                scope.selection.drag = true;
              } else{
                
              }
              
              scope.$digest();
            }
          });
          
          $window.bind('touchend touchcancel mouseup', function(e){
            if(scope.selection.drag){
              scope.selection.drag = false;
              if(scope.selection.dest){
                scope.selection.dest.steps = Math.round(scope.selection.dest.steps);
              }
              e.preventDefault();
              e.stopPropagation();
              scope.$digest();
            }
          });
          
          
          $window.bind('touchmove mousemove', function(e){
            var event = e.touches && e.touches[0] || e;
            
            if(scope.selection.drag && scope.selection.piece){
                
              var x1 = scope.selection.origin.x, x2 = (event.clientX - scope.offset.left) / scope.unit;
              var y1 = scope.selection.origin.y, y2 = (event.clientY - scope.offset.top) / scope.unit;
              var delta = { x: x2 - x1, y: y2 - y1 };
              
              var dest = Object.keys(scope.selection.moves).filter(function(dir){
                return scope.selection.moves[dir];
              }).map(function(dir){
                return { dir: dir, steps: mathUtils.dot(CARDINAL_VECTORS[dir], delta) };
              }).sort(function(a, b){
                return b.steps - a.steps;
              })[0];

              if(dest){
                dest.steps = dest.steps / dest.dir.length;
                dest.steps = Math.max(dest.steps, 0);
                dest.steps = Math.min(dest.steps, scope.selection.moves[dest.dir]);
                
                scope.selection.dest = dest;
              }
              
              e.preventDefault();
              e.stopPropagation();
            }
          });
          
          function getUnit(){
            scope.offset  = $grid.getBoundingClientRect();
            scope.unit    = scope.offset.width / scope.game.board.size;
          }
          
          $window.bind('resize', getUnit);
          $timeout(getUnit);
          
          // scope.$watch('game.turn', function(turn){
          //   if(turn){
          //     [].slice.call(document.querySelectorAll('defs animate')).forEach(function(elem){
          //       elem.beginElement();
          //     });
          //   }
          // });
        })();
      },
      templateUrl: 'board.tpl.html'
    };
  }])
  
  .directive('dragonBoardPiece', ['CARDINAL_VECTORS', function(CARDINAL_VECTORS){
    return {
      restrict: 'E',
      scope: {
        $board: '=',
        piece: '='
      },
      link: function(scope, elem, attrs){
        scope.star = 'M10,50 C25,50 50,25 50,10 C50,25 75,50 90,50 C75,50 50,75 50,90 C50,75 25,50 10,50 Z';

        scope.getTransform = function(){
          var offset = { x: 0, y: 0 }, unit;
          
          if(scope.$board.selection.piece === scope.piece && scope.$board.selection.move.steps){
            unit = scope.$board.selection.piece.type.size * scope.$board.selection.move.steps;
            offset.x = -Math.cos(CARDINAL_VECTORS[scope.$board.selection.move.dir].a * (Math.PI / 180)) * unit;
            offset.y =  Math.sin(CARDINAL_VECTORS[scope.$board.selection.move.dir].a * (Math.PI / 180)) * unit;
            
            if(scope.$board.selection.move.dir.length === 2){
              offset.x = offset.x * Math.sqrt(2);
              offset.y = offset.y * Math.sqrt(2);
            }
          }
                
          return 'translate(' +
                  ((scope.piece.space.x - offset.x) * 100 / scope.$board.game.board.size) + ' ' +
                  ((scope.piece.space.y - offset.y) * 100 / scope.$board.game.board.size) + ') ' +
                 'scale(' + (1 / scope.$board.game.board.size) + ' ' + (1 / scope.$board.game.board.size) + ')';
        }
      },
      templateUrl: 'board-piece.tpl.html'
    };
  }])
  
  .directive('dragonBoardLinks', ['RecursionHelper', 'CARDINAL_VECTORS', 'mathUtils',
    function(RecursionHelper, CARDINAL_VECTORS, mathUtils){
    
    return {
      restrict: 'A',
      scope: {
        $board: '=',
        piece: '=',
        index: '='
      },
      compile: function(elem){
        return RecursionHelper.compile(elem, function(scope){
          
          scope.curve = 'M0,15 C25,35 75,35 100,15 L100,85 C75,65 25,65 0,85 Z';
          
          scope.getTransform = function(){
            scope.offset = angular.copy(CARDINAL_VECTORS[scope.piece.links[scope.index]]);
            var frames, floor, ceil, fraction, a, b, c, start, end;
            
            if(scope.$board.selection.piece === scope.piece
              && scope.$board.selection.move && scope.$board.selection.move.steps){
              
              frames    = scope.$board.selection.frames[scope.$board.selection.move.dir];
              floor     = Math.floor(scope.$board.selection.move.steps);
              ceil      = Math.ceil(scope.$board.selection.move.steps);
              fraction  = scope.$board.selection.move.steps - floor;
              
              a = frames[floor][scope.index];
              b = frames[ceil][scope.index];
              
              start = CARDINAL_VECTORS[a];
              end   = CARDINAL_VECTORS[b];
              
              if(a !== b){ //changing directions
                
                scope.offset.x = mathUtils.tween(fraction, start.x, end.x - start.x, 1);
                scope.offset.y = mathUtils.tween(fraction, start.y, end.y - start.y, 1);
                
                c = end.a - start.a;
                if(c > 180){ c -= 360; }
                if(c < -180){ c += 360; }
                
                scope.offset.a = mathUtils.tween(fraction, start.a, c, 1);
                
                
                
                //a -> b => 0 -> 0.5 -> 1
                //h -> h => 1 -> Math.sqrt(0.5) -> 1
                //h -> d => 1 -> Math.sqrt(1.25) -> Math.sqrt(2)
                //d -> h => Math.sqrt(2) -> Math.sqrt(1.25) -> 1
                //d -> d => Math.sqrt(2) -> 1 -> Math.sqrt(2)
                
                switch(a.length + b.length){
                  case 2:
                    c = Math.sqrt(0.5);
                    break;
                  case 3:
                    c = Math.sqrt(1.25);
                    break;
                  case 4:
                    c = 1;
                    break;
                }
                
                if(fraction < 0.5){
                  scope.offset.s = mathUtils.tween(fraction, start.s, c - start.s, 0.5);
                }else {
                  scope.offset.s = mathUtils.tween(fraction - 0.5, c, end.s - c, 0.5);
                }
              } else {
                scope.offset = end;
              }
              
              
            }
            return '';
          }
          
        });
      },
      templateUrl: 'board-links.tpl.html'
    };
  }])
  
  .directive('dragonBoardControl', function(){
    function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
      var s = angleInDegrees * Math.PI / 180.0;
      var x = centerX + radius * Math.cos(s);
      var y = centerY + radius * Math.sin(s);
      return [x, y].join(',');
    }
    
    return {
      restrict: 'E',
      scope: {
        game: '='
      },
      link: function(scope, elem, attrs){
        
        scope.pie = function(player){
          var total = 0;
          angular.forEach(scope.game.control, function(control, p){
            total += control;
          });
          var deg = 360 * scope.game.control[player] / total;
          var end = polarToCartesian(28, 28, 28, deg);
          var flag = deg > 180 ? '1,1' : '0,1';
          
          return 'M28,28 L56,28 A28,28 0 ' + flag + end + ' Z';
        }
        
      },
      templateUrl: 'board-control.tpl.html'
    };
  })
  
  .filter('ceil', function() {
    return function(value) {
      return Math.ceil(value);
    };
  })
  
  ;
</script>
<style>
  dragon-board {
    width: 100%;
    height: 100%;
    display: block;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
  
  dragon-board .static {
    pointer-events: none;
  }
  
  dragon-board .board-bar{
    width: 100%;
    max-width: 500px;
    padding: 5px;
    height: 70px;
  }
  
  dragon-board md-button + md-button {
    margin-left: 15px;
  }
  
  dragon-board .field {
    position: relative;
    border-radius: 10px;
    width: 100%;
    max-width: 500px;
    z-index: 0;
  }
  
  dragon-board .field[turn="1"] {
    border: 10px solid rgba(3, 169, 244, 0.25);
  }
  
  dragon-board .field[turn="2"] {
    border: 10px solid rgba(96, 125, 139, 0.25);
  }
  
  
  @-webkit-keyframes ripple {
    from {
      background-size: 10%;
    }
    
    to {
      background-size: 150%;
    }
  }
  
  @-moz-keyframes ripple {
    from {
      background-size: 10%;
    }
    
    to {
      background-size: 150%;
    }
  }
  
  @keyframes ripple {
    from {
      background-size: 10%;
    }
    
    to {
      background-size: 150%;
    }
  }
  
  
  dragon-board .field .highlight:after {
    content: ' ';
    position: absolute;
    top: 0;
    bottom: 0;
    right: 0;
    left: 0;
    z-index: 1;
    background-repeat: no-repeat;
    background-size: 0%;
    background-position: center;
    
    -webkit-animation: ripple 0.1s linear;
    -moz-animation: ripple 0.1s linear;
    animation: ripple 0.1s linear;
    
    -webkit-animation-fill-mode: forwards;
    -moz-animation-fill-mode: forwards;
    animation-fill-mode: forwards;
  }
  
  dragon-board .field .highlight[size="2"]:after{
    right: -100%;
    bottom: -100%;
  }
  
  dragon-board .field .highlight[steps="1"]:after{
    -webkit-animation-delay: 0.1s;
    -moz-animation-delay: 0.1s;
    animation-delay: 0.1s;
  }
  
  dragon-board .field .highlight[steps="2"]:after{
    -webkit-animation-delay: 0.2s;
    -moz-animation-delay: 0.2s;
    animation-delay: 0.2s;
  }
  
  dragon-board .field .highlight[steps="3"]:after{
    -webkit-animation-delay: 0.3s;
    -moz-animation-delay: 0.3s;
    animation-delay: 0.3s;
  }
  
  dragon-board .field .highlight[steps="4"]:after{
    -webkit-animation-delay: 0.4s;
    -moz-animation-delay: 0.4s;
    animation-delay: 0.4s;
  }
  
  dragon-board .field .highlight[steps="5"]:after{
    -webkit-animation-delay: 0.5s;
    -moz-animation-delay: 0.5s;
    animation-delay: 0.5s;
  }
  
  dragon-board .field .highlight[steps="6"]:after{
    -webkit-animation-delay: 0.6s;
    -moz-animation-delay: 0.6s;
    animation-delay: 0.6s;
  }
  
  dragon-board .field .highlight[steps="7"]:after{
    -webkit-animation-delay: 0.7s;
    -moz-animation-delay: 0.7s;
    animation-delay: 0.7s;
  }
  
  dragon-board .field .highlight[steps="8"]:after{
    -webkit-animation-delay: 0.8s;
    -moz-animation-delay: 0.8s;
    animation-delay: 0.8s;
  }
  
  dragon-board .field .highlight[steps="9"]:after{
    -webkit-animation-delay: 0.9s;
    -moz-animation-delay: 0.9s;
    animation-delay: 0.9s;
  }
  
  dragon-board .field .highlight[steps="10"]:after{
    -webkit-animation-delay: 1.0s;
    -moz-animation-delay: 1,0s;
    animation-delay: 1.0s;
  }
  
  dragon-board .field .highlight[steps="11"]:after{
    -webkit-animation-delay: 1.1s;
    -moz-animation-delay: 1.1s;
    animation-delay: 1.1s;
  }
  
  dragon-board .field .highlight[steps="12"]:after{
    -webkit-animation-delay: 1.2s;
    -moz-animation-delay: 1.2s;
    animation-delay: 1.2s;
  }
  
  dragon-board .field[turn="1"] .highlight:after {
    background-image:
      url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='50' height='50'><circle cx='25' cy='25' r='25' fill='#03a9f4' opacity='0.25' /></svg>");
  }
  
  dragon-board .field[turn="2"] .highlight:after {
    background-image:
      url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='50' height='50'><circle cx='25' cy='25' r='25' fill='#607d8b' opacity='0.25' /></svg>");
  }
  
  dragon-board .field .win {
    position: absolute;
    color: #fff;
    font-size: 24px;
    z-index: 5;
  }
  
  dragon-board .win .label {
    padding: 15px;
    border-radius: 5px;
  }
  
  dragon-board .field[turn="1"] .win {
    background: rgba(3, 169, 244, 0.25);
  }
  
  dragon-board .field[turn="2"] .win {
    background: rgba(96, 125, 139, 0.25);
  }
  
  dragon-board .field[turn="1"] .win .label {
    background: rgba(3, 169, 244, 1);
  }
  
  dragon-board .field[turn="2"] .win .label {
    background: rgba(96, 125, 139, 1);
  }
  
  dragon-board .field .grid {
    position: relative;
    padding-bottom: 100%;
  }
  
  dragon-board .field .grid > div {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
  
  dragon-board .dragon-row:nth-child(odd) .space:nth-child(odd) {
    background-color: #f3f3f3;
  }
  dragon-board .dragon-row:nth-child(even) .space:nth-child(even) {
    background-color: #f3f3f3;
  }
  
  dragon-board .space {
    position: relative;
  }
  
  dragon-board dragon-board-piece, dragon-board dragon-board-link {
    position: absolute;
    display: block;
    top: 0;
    right: 0;
    left: 0;
    bottom: 0;
  }
  
  dragon-board dragon-board-piece svg, dragon-board dragon-board-link svg {
    display: block;
    position: absolute;
    z-index: 2;
    overflow: visible;
  }
  
  dragon-board dragon-board-piece, dragon-board dragon-board-link {
    pointer-events: none;
  }
  
  dragon-board .player-0 .primary, dragon-board .player-0.primary {
    fill: #fff;
  }
  
  dragon-board .player-1 .primary, dragon-board .player-1.primary {
    fill: #03a9f4;
  }
  
  dragon-board .player-1 .secondary, dragon-board .player-1.secondary {
    fill: #0288d1;
  }
  
  dragon-board .player-2 .primary, dragon-board .player-2.primary {
    fill: #607d8b;
  }
  
  dragon-board .player-2 .secondary, dragon-board .player-2.secondary {
    fill: #455a64;
  }
  
  dragon-board-control {
    display: inline-block;
    width: 56px;
    height: 56px;
  }
  
  dragon-board-control svg {
    /*display: absolute;*/
  }
  
</style>

<template id="board.tpl.html">
  <div layout="column" layout-fill layout-align="center center" ng-class="{ static: static }">
    
    <div class="board-bar" layout="row" hide show-sm ng-hide="static">
    
      <div>
        <div>
          <md-button class="md-primary" aria-label="Accept move" ng-click="accept()"
            ng-disabled="!selection.move || !selection.move.steps">
            <i class="md md-check md-2x" style="transform: rotate(180deg)"></i>
          </md-button>
          <md-button class="md-warn" aria-label="Cancel move" ng-click="cancel()"
            ng-disabled="!selection.move || !selection.move.steps">
            <i class="md md-close md-2x"></i>
          </md-button>
        </div>
      </div>
      <div style="transform: rotate(180deg)" flex>
        <!--<dragon-board-control game="game"></dragon-board-control>-->
      </div>
      <!--<div flex style="text-align: right">-->
      <!--  <md-button class="md-fab" aria-label="Restart Game" ng-click="restart()">-->
      <!--    <i class="md md-refresh md-2x"></i>-->
      <!--  </md-button>-->
      <!--  <md-button class="md-fab" aria-label="Full Screen" ng-click="fullscreen()">-->
      <!--    <i class="md md-fullscreen md-2x"-->
      <!--      ng-class="{ 'md-fullscreen': !screenfull.isFullscreen, 'md-fullscreen-exit': screenfull.isFullscreen}"></i>-->
      <!--  </md-button>-->
      <!--</div>-->
    </div>
    
    <div class="field" turn="{{win || game.turn + 1}}">
      <div class="win" ng-show="win" layout="column" layout-fill layout-align="center center">
        <span class="label">Player {{win}} Wins!</span>
      </div>
      <div class="grid">
        <div layout="column">
          <div layout="row" ng-repeat="row in game.board.rows track by $index" class="dragon-row" flex>
            <div class="space" size="{{space.highlight.size}}" steps="{{space.highlight.steps}}" ng-class="{ highlight: !!space.highlight }" ng-repeat="space in row track by $index" space="space" flex>
            </div>
          </div>
          <dragon-board-piece ng-repeat="piece in game.pieces track by $index" $board="this" piece="piece">
          </dragon-board-piece>
        </div>
      </div>
    </div>
    
    <div class="board-bar" layout="row" ng-hide="static">
      <div flex>
        <!--<dragon-board-control game="game"></dragon-board-control>-->
      </div>
      <div style="text-align: right">
        <div>
          <md-button class="md-warn" aria-label="Cancel move"  ng-click="cancel()"
            ng-disabled="!selection.move || !selection.move.steps">
            <i class="md md-close md-2x"></i>
          </md-button>
          <md-button class="md-primary" aria-label="Accept move" ng-click="accept()"
            ng-disabled="!selection.move || !selection.move.steps">
            <i class="md md-check md-2x"></i>
          </md-button>
        </div>
      </div>
      
    </div>
    
  </div>
  
  <svg ng-hide="true">
    <defs>
    
      <filter id="svg-shadow-raise">
        <feOffset result="offOut" in="SourceAlpha" dx="0" dy="0">
          <animate attributeName="dx" dur="0.25s" from="0" to="3" begin="indefinite" fill="freeze" />
          <animate attributeName="dy" dur="0.25s" from="0" to="7" begin="indefinite" fill="freeze" />
        </feOffset>
        <feGaussianBlur result="blurOut" in="offOut" stdDeviation="2" />
        <feColorMatrix in="blurOut" result="opacityOut" type="matrix"
          values="0 0 0 0   0
                  0 0 0 0   0
                  0 0 0 0   0
                  0 0 0 .26 0"/>
        <feBlend in="SourceGraphic" in2="opacityOut" mode="normal" />
      </filter>
      
      <filter id="svg-shadow-lower">
        <feOffset result="offOut" in="SourceAlpha" dx="0" dy="0">
          <animate attributeName="dx" dur="0.25s" from="3" to="0" begin="indefinite" fill="freeze" />
          <animate attributeName="dy" dur="0.25s" from="7" to="0" begin="indefinite" fill="freeze" />
        </feOffset>
        <feGaussianBlur result="blurOut" in="offOut" stdDeviation="2" />
        <feColorMatrix in="blurOut" result="opacityOut" type="matrix"
          values="0 0 0 0   0
                  0 0 0 0   0
                  0 0 0 0   0
                  0 0 0 .26 0"/>
        <feBlend in="SourceGraphic" in2="opacityOut" mode="normal" />
      </filter>
      
    </defs>
  </svg>
</template>

<template id="board-piece.tpl.html">
  <svg height="100%" width="100%" viewbox="0 0 100 100" class="player-{{::piece.player + 1}}" >
    
    <!--ng-attr-filter="url(#svg-shadow-{{game.turn === piece.player ? 'raise': 'lower'}})"-->
    <g ng-attr-transform="{{getTransform()}}">
    
      <g ng-attr-transform="scale({{::piece.type.size}} {{::piece.type.size}})">
        
        <svg dragon-board-links $board="::$board" piece="::piece" index="::0" ng-if="::piece.links[0]"></svg>
        
        <circle cx="50" cy="50" r="45" class="primary" />
        <circle cx="50" cy="50" r="30" class="secondary" ng-if="::piece.type.index !== 0"/>
        <path ng-attr-d="{{::star}}" class="secondary" ng-if="::piece.type.index === 0" />
        
      </g>
    </g>
  </svg>
</template>

<template id="board-links.tpl.html">

  <g ng-attr-transform="translate({{getTransform()}}{{offset.x * 100}} {{offset.y * 100}})">
    <circle cx="50" cy="50" r="45" class="primary"></circle>
    <g ng-attr-transform="rotate({{180 - offset.a}} 50 50)">
      <path ng-attr-d="{{::curve}}" class="primary"
        ng-attr-transform="translate(50 0) scale({{offset.s}} 1)"></path>
    </g>
    
    <svg dragon-board-links $board="::$board" piece="::piece" index="::index + 1" ng-if="::piece.links[index + 1]"></svg>
  </g>
</template>

<template id="board-control.tpl.html">
  <div class="player-{{::game.players[0]}} primary" style="width: 100%; height: 25px; background: #ff0">
    
  </div>
</template>

<template id="x-board-control.tpl.html">
  <svg width="56" height="56">
    <circle cx="28" cy="28" r="28" class="player-{{::game.players[0]}} primary" />
    <path ng-repeat="p in game.players.slice(1)" ng-attr-d="{{pie(p)}}" class="player-{{p}} primary" stroke="white"></path>
    
    <g ng-if="game.controlling">
      <circle cx="28" cy="28" r="15" class="player-{{game.controlling}} primary" stroke="white" stroke-width="3" />
      <text x="28" y="34" text-anchor="middle" fill="white">{{game.countdown | ceil}}</text>
    </g>
    
    <g ng-if="game.controlling === null">
      <circle cx="28" cy="28" r="15" fill="white" stroke="white" stroke-width="3" />
    </g>
  </svg>
</template>